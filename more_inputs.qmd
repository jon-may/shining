---
title: "More Inputs"
---

Let's edit the app so that the user can specify the weights of x used to compute y instead of uploading a file.

First replace the **fileInput()** by a **numericInput()** for x

```         
numericInput("x","Weight for X:", min=0, max=1, step=.05, value=.5)
```

Then replace the three lines that read in the file with one line that creates the data on the fly

```         
data<-tibble(x=rnorm(1000,10,2),y=input$x*x+rnorm(1000,10,2)*(1-input$x))
```

This makes the **output\$distplot** re-run every time you change the value for the weight of X.

![](images/random.png){width="300"}

If it does not work, then check that your server function looks like this:

```         
server <- function(input, output) {
    output$distPlot <- renderPlot({
         data<-tibble(x=rnorm(1000,10,2),y=input$x*x+rnorm(1000,10,2)*(1-input$x))
         data|>ggplot((aes(x=x, y=y)))+geom_point()+theme_minimal()
    })
}
```

It is quite boring, so lets specify the colour of the points, using a **radioButtons()** and their shape using **selectInput().** Edit the **sidebarPanel** to include these inputs.

```         
sidebarPanel(
           numericInput("x","Weight for X:", min=0, max=1, step=.05, value=.5),
           radioButtons("colour","Point colour:",c("red","blue","green","yellow")),
           selectInput("shape","Point Shape:",choices = c(0:8))
       ),
```

To make these have an effect edit the line in **output\$distPlot** that draws the scatterplot so that it becomes:

```         
         data|>ggplot((aes(x=x, y=y)))+
            geom_point(colour=input$colour,shape=as.numeric(input$shape))+
            theme_minimal()
```

Notice that because **selectInput()** provides a character string, we have to convert it to numeric for the shape to work (otherwise all the points will be little numbers).
