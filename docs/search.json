[
  {
    "objectID": "first_steps.html",
    "href": "first_steps.html",
    "title": "First steps",
    "section": "",
    "text": "Open RStudio and if you have not already done so, install the packages shiny and (for later bslib.\n\nTo be tidy, it is best to keep your work in a Project, although you can work with separate files.\nUse the  icon in the RStudio menubar to create a new R project in a new directory, and then select a Shiny Application. Give it a sensible name (best to keep it short and meaningful, without spaces). Check the box to open in a new session.\n\nThis will create a new folder, containing your project file and a file named app.R - this is where you will write your shiny code. You can rename it, but there is no need. If you asked for a new session, app.R will also open in a new RStudio window.\nAt first, app.R contains some demo code. There are some comments, then code to load the library shiny, a chunk to define an object ui (the user interface), a chunk to define a function called server (the code that creates the objects in ui), and a line that uses the shinyApp function using the ui object and the server function.\n\nIn this screen shot I have edited the code a bit to fold it up so that you can see these three chunks. All your shiny apps will follow this basic format - load libraries, ui, the server and shinyApp().\nThe default code provided is a runnable shiny app, and you can run it using the  button that has appeared at the top of the editor pane. When you do you should see this:\n\nThat’s it - you’ve made a shiny app! Play with the slider to see the graph update.\nThe next steps will be to make it do what you want to do instead of showing the default content."
  },
  {
    "objectID": "publish.html",
    "href": "publish.html",
    "title": "Publishing",
    "section": "",
    "text": "Your app is all very nice, but at the moment it only runs on your computer. To make it generally available to people you have to publish it on a shiny server.\nYou can publish up to five apps at a time for free on posit’s website shinyapps.io, so follow the link and create yourself an account.\nYou’ll need to think of a name for your account - this will be the first part of the URL for your published app, so keep it short.\nThen you’ll be shown three steps to follow, but only do 1 and 2.\nStep 1 is easy - you just need to install the rsconnect package in RStudio.\nStep 2 links your RStudio with your shinyapps.io account. You only need to click the lower green button (Copy to clipboard) and then paste into the console.\nWhen you have done this, the  button in your Editor pane will let you upload your app.R to the shinyapps.io server.\n\nWhen I clicked it, this is what I saw. I had saved two files of random numbers alongside my app.R file in the folder newshinyapp. I did not want to upload those csv files to the server, so I unchecked the boxes. I have two accounts there, so I selected jmpersonal.\nThen I clicked Publish. When you do this a Deploy pane opens and lots of things happen in red, and it takes a few minutes, but then a browser window will open with your publicly accessible app - here is the URL to mine: https://jmpersonal.shinyapps.io/newshinyapp)\nIf anything goes wrong, then you’ll need to inspect your logs on shinyapps.io to see the error code that would normally be in the console. To do this, log into your account, and go to Applications &gt;&gt; All. Click the gearwheel icon alongside your app, and select the Logs icon from the menubar. The errors will be logged here, but as with the Console, you might need to think a bit to solve them."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This tutorial was first written in June 2025 by Jon May, using Quarto, to help Jon Rhodes."
  },
  {
    "objectID": "more_outputs.html",
    "href": "more_outputs.html",
    "title": "More outputs",
    "section": "",
    "text": "Text output is OK for short snippets, but to do more complicated formatting you need to create HTML strings which include heading tags such as &lt;h3&gt; or &lt;/br&gt;.\nIn the ui, add a comma to the end of plotOutput(“distPlot”) and underneath, add:\nhtmlOutput(\"regression\") \nThen in server, add this object:\noutput$regression &lt;- renderUI({\n       if(!is.null(input$file)){\n          d&lt;-data()\n          m&lt;-lm(data=d, y ~ x)\n          r&lt;-cor.test(d$x, d$y)\n          \n          HTML(paste(\"&lt;h3&gt;Correlation: r = \",round(r$estimate,3),\"&lt;/h3&gt;&lt;/br&gt;&lt;/br&gt;\",\n                \"&lt;h3&gt;Regression: Y = \",round(m$coefficient[1],2),\" + X * \",round(m$coefficient[2],2),\"&lt;/h3&gt;\"))\n          \n       }\n    })\nThis accesses the data that was used for the scatterplot (it will only be recreated when any of the inputs change), and creates a linear regression model in m and a correlation in r.\nThe HTML(…) command builds a string of HTML markup, containing some markup tags, text, and digs into m and r to extract the results you want to display, rounding them to three or two decimal places.\n\nNB you can see what is in m and r if you make a tibble d in the console and run the lines to do the lm() and cor.test() - look in the Environment pane to unpack the objects you’ve built. Type summary(m) and compare the output with the object’s contents."
  },
  {
    "objectID": "more_outputs.html#add-html-output",
    "href": "more_outputs.html#add-html-output",
    "title": "More outputs",
    "section": "",
    "text": "Text output is OK for short snippets, but to do more complicated formatting you need to create HTML strings which include heading tags such as &lt;h3&gt; or &lt;/br&gt;.\nIn the ui, add a comma to the end of plotOutput(“distPlot”) and underneath, add:\nhtmlOutput(\"regression\") \nThen in server, add this object:\noutput$regression &lt;- renderUI({\n       if(!is.null(input$file)){\n          d&lt;-data()\n          m&lt;-lm(data=d, y ~ x)\n          r&lt;-cor.test(d$x, d$y)\n          \n          HTML(paste(\"&lt;h3&gt;Correlation: r = \",round(r$estimate,3),\"&lt;/h3&gt;&lt;/br&gt;&lt;/br&gt;\",\n                \"&lt;h3&gt;Regression: Y = \",round(m$coefficient[1],2),\" + X * \",round(m$coefficient[2],2),\"&lt;/h3&gt;\"))\n          \n       }\n    })\nThis accesses the data that was used for the scatterplot (it will only be recreated when any of the inputs change), and creates a linear regression model in m and a correlation in r.\nThe HTML(…) command builds a string of HTML markup, containing some markup tags, text, and digs into m and r to extract the results you want to display, rounding them to three or two decimal places.\n\nNB you can see what is in m and r if you make a tibble d in the console and run the lines to do the lm() and cor.test() - look in the Environment pane to unpack the objects you’ve built. Type summary(m) and compare the output with the object’s contents."
  },
  {
    "objectID": "create_1.html",
    "href": "create_1.html",
    "title": "Creating an app",
    "section": "",
    "text": "The easiest way to start creating an app is the use the default one, and replace its content with your own.\nAs an example, we will create an app that asks for a file of data, and then draws a distribution of the data and reports some descriptives. You can then play with it to try out different features.\nBefore we start, we will need some random data to give the app. Here is some R code you can use to create the data we will begin with - you can paste it into the console:\nThis makes a CSV file in your working directory called random.csv with 1000 rows, where x is a random value with a mean of 10 and a standard deviation of 2.\nSome of what we will do needs tidyverse, so we will need to add this line to the top of the app.R file."
  },
  {
    "objectID": "create_1.html#edit-the-input",
    "href": "create_1.html#edit-the-input",
    "title": "Creating an app",
    "section": "Edit the input",
    "text": "Edit the input\nReturn to the default app.R (or create a new one) and replace the code that created the slider with code to read in a filename. To do this, delete lines 21 to 25 - everything defining the sliderInput - and replace it with this:\n          fileInput(\"file\",\"Data:\")\nAs you’d expect, this allows the user to Browse to find a file, or to drop a file onto the slot. Notice that both the object’s name and label need to be in quotes."
  },
  {
    "objectID": "create_1.html#edit-the-output",
    "href": "create_1.html#edit-the-output",
    "title": "Creating an app",
    "section": "Edit the output",
    "text": "Edit the output\nDelete the lines in output$distplot that create x, bins and the histogram. You should be left with this:\nserver &lt;- function(input, output) {\n\n    output$distPlot &lt;- renderPlot({\n    })\n}\nInside the renderPlot({…}), type or paste this code:\nif(!is.null(input$file)){\n         file&lt;-input$file\n         data&lt;-read_csv(file$datapath)\n         data|&gt;ggplot((aes(x=x)))+geom_density()+theme_minimal()\n       }\nWhen you run the app and drop the random.csv file into the Data slot you should see a density plot appear.\nHere is what the four lines do:\nThe if() line only runs the code once a file has been chosen, to avoid Errors.\nfile is set to the details of the file that has been selected - it is not the file contents yet though!\ndata is set to the contents of the file - and as you can see file is an object that contains a component called datapath. file$datapath is actually a pointer to the file on your computer.\nThe last line draws the density plot.\nWhatever is computed by the last line in a function is returned as the result of that function, so the plot is rendered as distPlot and shown on the ui.\nIf you rerun the code that creates random.csv to get new values then you can drop the new file into the Data slot and get a new plot.\nMaybe you could take a moment to edit the title so it does not claim to be Old Faithful Geyser Data.\nThis code will work on any csv file that contains a column of numbers called x, so it is a bit fragile, but it’s your first real shiny app."
  },
  {
    "objectID": "create_1.html#add-text-output",
    "href": "create_1.html#add-text-output",
    "title": "Creating an app",
    "section": "Add text output",
    "text": "Add text output\nWe can add some code to compute and report some descriptive statistics. To display the text on the ui you need to add a textOutput object, so call it descriptives and put it above the density plot:\nmainPanel(\n           textOutput(\"descriptives\"),\n           plotOutput(\"distPlot\")\n        )\nNow define what this text will be by adding its code to server:\noutput$descriptives &lt;- renderText({\n       if(!is.null(input$file)){ \n          file&lt;-input$file\n          data&lt;-read_csv(file$datapath)\n          paste(\"There are\",nrow(data),\n                \"observations of X with a mean of\",round(mean(data$x),1),\n                \"and a standard deviation of\",round(sd(data$x),2)\n                )\n          }\n      })\nTry running the app again. You should see the descriptives displayed above the density plot."
  },
  {
    "objectID": "create_1.html#reactive-objects",
    "href": "create_1.html#reactive-objects",
    "title": "Creating an app",
    "section": "Reactive objects",
    "text": "Reactive objects\nOne problem with this code is that lines to read in the code are repeated in both of the server objects. It works but would be effortful to modify to changed the file type, for example. You can economise by putting these two lines into their own object in server:\ndata&lt;-reactive({\n         file&lt;-input$file\n         data&lt;-read_csv(file$datapath)\n   })\nReactive objects are ones that do things that not need to appear directly on the ui.\nThis data object reacts to any change in input$file by reading the contents. The other objects in server can access it as data(), so the full server code can now be:\nserver &lt;- function(input, output) {\n   \n   data&lt;-reactive({\n      if(!is.null(input$file)){\n         file&lt;-input$file\n         data&lt;-read_csv(file$datapath)\n      }\n   })\n   \n    output$distPlot &lt;- renderPlot({\n       if(!is.null(input$file)){\n         data()|&gt;ggplot((aes(x=x)))+\n            geom_density()+\n            theme_minimal()\n       }\n    })\n    \n    output$descriptives &lt;- renderText({\n       if(!is.null(input$file)){ \n          data&lt;-data()\n          paste(\"There are\",nrow(data),\n                \"observations of X with a mean of\",round(mean(data$x),1),\n                \"and a standard deviation of\",round(sd(data$x),2)\n          )\n       }\n    })\n}"
  },
  {
    "objectID": "more_inputs.html",
    "href": "more_inputs.html",
    "title": "More Inputs",
    "section": "",
    "text": "Let’s edit the app so that it creates another variable based on the values of x.\nFirst add this function definition to the top of the file, before the ui\nmakey&lt;-function(x,w){w*x+rnorm(length(x),10,2)*(1-w)}\nIf you call this function with a vector of numbers x and a weight w, it will return a new vector that is \\[ x.w + e \\] where e is random.\nAdd a line that calls this function to the data function:\n  data&lt;-reactive({\n      if(!is.null(input$file)){\n         file&lt;-input$file\n         data&lt;-read_csv(file$datapath)\n         data&lt;-data|&gt;mutate(y=makey(x,.6))\n      }\n   })\nNext, change the ggplot code by replacing geom_dist() with geom_point() so that it produces a scatterplot instead of a density plot.\nTry it out by clicking \nIt is quite boring, so lets specify the colour of the points, using a radioButtons() and their shape using selectInput(). Edit the sidebarPanel to include these inputs.\n           radioButtons(\"colour\",\"Point colour:\",c(\"red\",\"blue\",\"green\",\"yellow\")),\n           selectInput(\"shape\",\"Point Shape:\",choices = c(0:8))\nTo make these have an effect edit the line in output$distPlot that draws the scatterplot so that it becomes:\n         data|&gt;ggplot((aes(x=x, y=y)))+\n            geom_point(colour=input$colour,shape=as.numeric(input$shape))+\n            theme_minimal()\nNotice that because selectInput() provides a character string, we have to convert it to numeric for the shape to work (otherwise all the points will be little numbers).\nTry it out by clicking \nFinally, add an input to sidebarPanel that lets you define the weight instead of it being fixed at 0.6:\n         numericInput(\"w\",\"Weight for X:\", min=0, max=1, step=.05, value=.5)\nand change the last line of the reactive data function:\n        data&lt;-data|&gt;mutate(y=makey(x,input$w))\n\nIn case you’ve got lost with all those brackets and commas, here is the complete code:\nlibrary(shiny)\nlibrary(tidyverse)\n\nmakey&lt;-function(x,w){w*x+rnorm(length(x),10,2)*(1-w)}\n\nui &lt;- fluidPage(\n   titlePanel(\"My random scatterplot\"),\n   sidebarLayout(\n      sidebarPanel(\n         fileInput(\"file\",\"Data:\"),\n         radioButtons(\"colour\",\"Point colour:\",c(\"red\",\"blue\",\"green\",\"yellow\")),\n         selectInput(\"shape\",\"Point Shape:\",choices = c(0:8)),\n         numericInput(\"w\",\"Weight for X:\", min=0, max=1, step=.05, value=.5)\n      ),\n      mainPanel(\n         textOutput(\"descriptives\"),\n         plotOutput(\"distPlot\")\n      )\n   )\n   )\n\nserver &lt;- function(input, output) {\n   \n   data&lt;-reactive({\n      if(!is.null(input$file)){\n         file&lt;-input$file\n         data&lt;-read_csv(file$datapath)\n         data&lt;-data|&gt;mutate(y=makey(x,input$w))\n      }\n   })\n   \n    output$distPlot &lt;- renderPlot({\n       if(!is.null(input$file)){\n         data()|&gt;ggplot((aes(x=x, y=y)))+\n            geom_point(colour=input$colour,shape=as.numeric(input$shape))+\n            theme_minimal()\n       }\n    })\n    \n    output$descriptives &lt;- renderText({\n       if(!is.null(input$file)){ \n          data&lt;-data()\n          paste(\"There are\",nrow(data),\n                \"observations with a mean of\",round(mean(data$x),1),\n                \"and a standard deviation of\",round(sd(data$x),2)\n          )\n       }\n    })\n}\n\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shining",
    "section": "",
    "text": "This is a tutorial on creating Shiny apps. It assumes the following:\n\nYou are comfortable using R\nYou have RStudio and R installed\n\nThis tutorial was last updated in June 2025.\nThe tutorial will show you how to create a new shiny app, add objects to the user interface, and define the code to read in a data file and produce some output.\nPlease use the menu at the top of the page to navigate (it may be a ‘hamburger’ icon)"
  },
  {
    "objectID": "server.html",
    "href": "server.html",
    "title": "Server Code",
    "section": "",
    "text": "The server code for the example only does one thing - it creates the distPlot graph using the value you’ve chosen using the bins slider.\nHere is the code:\nAll code in server links to the input and output objects by prefixing their names with input$ and output$. Here the code creates the distplot output object using the renderPlot() function upon the code contained in the curly braces {…}.\nFirst, x is set to contain column 2 of R’s built-in dataframe faithful (try typing faithful in the console to see it).\nThen bins is created as a sequence ranging from the minimum to the maximum value of x, with the number of bins defined by the value of the bins slider plus 1. Referring to the slider as input$bins lets the code keep it separate from the bins object, which is local to this function.\nFinally, a histogram is drawn using the vector x, with the breakpoints set to the values of bins.\nThe renderPlot() function turns this graphical into the output needed for the plotOutput interface function."
  },
  {
    "objectID": "server.html#reactivity",
    "href": "server.html#reactivity",
    "title": "Server Code",
    "section": "Reactivity",
    "text": "Reactivity\nThe whole point of a shiny app is to make the output change when the inputs change, a concept called reactivity.\nThis means that whenever any input object changes, any output object that refers to it is re-evaluated, its code will be run, and the ouptut will change appropriately. In turn, any change to an output object is immediately shown on the ui.\nHere, any change to the slider means that input$bins takes a new value, and as output$distPlot refers to it, this code will be re-run and a new histogram rendered upon the ui.\nThe shiny engine that does this keeps track of what has changed and what has not, so input objects that have not changed are not re-evaluated. This makes it quite efficient and you do not need to worry about saving the results of complicated operations to save repeating them; the engine does this automatically. For example, if you read in a data file using inputFile() and process it, that input and processing only happens once no matter how many times your code accesses the file object or its processed version - until you provide a new data file name."
  },
  {
    "objectID": "ui.html",
    "href": "ui.html",
    "title": "user interface",
    "section": "",
    "text": "The ui object in the default app is quite minimal, with a slider and a graph. The code looks more complex because it also includes functions to specify where in the app these two objects appear - the slider is in a sidebar and the graph is in the main panel of the window. There is also a title panel.\nThe slider is created by the sliderInput() and it is embedded within a sidebarPanel() that is part of the sidebarLayout().\nThe parameters passed to the sliderInput() call define the name of the slider (bins), the text to be displayed in the ui (Number of bins:), the minimum and maximum values (1 to 50) and the initial value (30). The name is not shown in the interface but is how the object will be referred to in the server code.\nThe graph is created by the plotOutput(), which is embedded within the mainPanel(). The graph that will be shown is called distPlot, and this will be created in the server code.\nBoth the sidebarLayout and the mainPanel are embedded within a fluidpage() call. A fluidpage is a layout that changes as the window is resized. If you have the app running, try making it narrower - when it gets too narrow, the sidebar will be moved above the main panel. There are many other ways of arranging the ui, and we’ll look at some later, but a fluidpage is a good place to start.\nThe sections below list the input and output types that you’ll need to use. A handy reference cheat sheet is available from Posit."
  },
  {
    "objectID": "ui.html#input-objects",
    "href": "ui.html#input-objects",
    "title": "user interface",
    "section": "Input objects",
    "text": "Input objects\nThe sliderInput() is just one of many different ways of providing user input to the app. Here is a list of other commonly used inputs:\n\nactionButton() - a labelled button that will execute some code when clicked\ncheckboxInput() - a single checkbox you can use to turn something on or off\nfileInput() - lets the user upload a data file\nnumericInput() - a dropdown where a number can be chosen (as for a slider)\nradioButtons() - a visible set of mutually exclusive options (best for a small set)\nselectInput() - a dropdown list of mutually exclusive options (best for a longer set)\ntextInput() - lets the user enter text\n\n…and some less common inputs:\n\ncheckboxGroupInput() - a visible set of choices that are not mutually exclusive\ndateInput() - specify a date by typing in the correct format e.g., dd-mm-yyyy\ndateRangeInput() - two linked date inputs\npasswordInput() - like textInput but blobs instead of letters shown\ntextAreaInput() - like textInput but with a stretchable box to type into\n\nYou can find"
  },
  {
    "objectID": "ui.html#output-objects",
    "href": "ui.html#output-objects",
    "title": "user interface",
    "section": "Output objects",
    "text": "Output objects\nThe most commonly used output objects are:\n\nplotOutput() - to show some graphical output e.g., from ggplot\ntextOutput() - plain text, best for short labels and headings\nhtmlOutput() - a string containing HTML markup, for longer formatted text\ntableOutput() - presents a dataframe\nimageOutput() - to show a graphic saved in a file e.g., a logo"
  },
  {
    "objectID": "layout.html",
    "href": "layout.html",
    "title": "Layout",
    "section": "",
    "text": "This page will tell you how to customise the layout of your app using tab panels, cards, and themes."
  },
  {
    "objectID": "layout.html#tab-panels",
    "href": "layout.html#tab-panels",
    "title": "Layout",
    "section": "Tab panels",
    "text": "Tab panels\nOnce you start to get more output than will fit easily on a screen, you might want to split it up between different tabs. This can also help a user move between input, processing and output phases of a task by putting the Input and Output objects on different tabs.\nHere is a screenshot of part of a tabbed app, with four separate tabs:\n\nTabs are created in the ui using code with the following structure:\ntabsetPanel(type=\"tabs\",  # or type=\"pills\"\n   tabPanel(\"Name1\", ...content...),\n   tabPanel(\"Name2\", ...content...),\n   tabPanel(\"Name3\", ...content...)\n   )\nwhere the content is a series of ui objects. For example, the example app could use this code in mainPanel:\nmainPanel(\n         tabsetPanel(type=\"pills\",\n           tabPane(\"Descriptives\",textOutput(\"descriptives\")),\n           tabPane(\"Graph\",plotOutput(\"distPlot\"))\n         )\n      )"
  },
  {
    "objectID": "layout.html#cards",
    "href": "layout.html#cards",
    "title": "Layout",
    "section": "Cards",
    "text": "Cards\nYou can control where ui elements appear on a page using a card layout, provided that you have set\nui&lt;-page_fillable(\nNotionally a shiny app is divided into twelve columns, and you can specify how many columns a card spans. the basic code structure is this:\nlayout_columns(\n  card( card_header(\"Card1\"), ...contents... ),\n  card( card_header(\"Card2\"), ...contents... ),\n  card( card_header(\"Card3\"), ...contents... ),\n  card( card_header(\"Card4\"), ...contents... ),\n  card( card_header(\"Card5\"), ...contents... ),\n  col_widths = c(2,5,5, 6,6),\n  row_heights = c(2,5)\n  )\nThis should put Cards 1 to 3 on the first row, and Cards 4 and 5 on the second row. Card 1 would be 2/12th of the width, Cards 2 and 3 5/12ths. The first row would take up 2/7th of the page, the second row 5/7th."
  },
  {
    "objectID": "layout.html#themes",
    "href": "layout.html#themes",
    "title": "Layout",
    "section": "Themes",
    "text": "Themes\nAll shiny apps have a Cascading Style Sheet format (.css) and the bslib package allows you to customise it easily.\nAt the top of the app code, add the line\nlibrary(bslib)\nand then at the start of the ui definition, add a theme:\nui &lt;- page_fillable(\n theme = bs_theme(\n    bootswatch = \"darkly\",\n     primary = \"#007777\",\n     success = \"#4CF4F4\",\n     secondary = \"#4C7F7F\",\n     danger = \"#FF0000\",\n    \"table-color\" = \"#4CF4F4\",\n    base_font = font_google(\"Encode Sans Condensed\"),\n    font_weight_base = \"font-weight-light\",\n    headings_font_weight = 300,\n    font_scale = .7\n  ),\nThis loads the preset darkly theme from bootswatch.com and then specifies colours for the standard css categories, adds a colour for tables, and chooses a font from the free Google font collection, setting its size. There is a huge amount that you can do with this."
  }
]